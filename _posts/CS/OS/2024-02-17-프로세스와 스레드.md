---
title: 프로세스와 스레드
description: OperatingSystem - Process, Thread
author: subeenjeon
date: 2024-02-17
categories: [ CS, Operating System ]
tags: [ OS ]
pin: true
math: true
mermaid: true
toc: true
image:
#  path: /commons/devices-mockup.png
#  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
#  alt: Responsive rendering of Chirpy theme on multiple devices.
---

<!-- TOC -->
* [☻ 프로세스와 스레드](#-프로세스와-스레드)
* [☺︎ 프로세스(Process)](#-프로세스process)
  * [프로세스 제어 블록(PCB)](#프로세스-제어-블록pcb)
  * [☺︎ 프로세스 상태 전이](#-프로세스-상태-전이)
 
* [☻ 프로세스 교착상태](#-프로세스-교착상태)
  * [프로세스 교착상태(데드락, Deadlock)](#프로세스-교착상태데드락-deadlock)
    * [교착상태는 왜 발생하는가?](#교착상태는-왜-발생하는가)
* [☻ 스레드(Thread)](#-스레드thread)
  * [스레드](#스레드)
  * [프로세스와 스레드의 차이?](#프로세스와-스레드의-차이)
    * [즉, 프로세스와 스레드의 차이는](#즉-프로세스와-스레드의-차이는)
    * [왜 프로세스와 스레드를 분리한 거지](#왜-프로세스와-스레드를-분리한-거지)
* [☺︎ 프로세스 스케쥴링](#-프로세스-스케쥴링)
    * [선점형 스케줄링 (Preemptive Scheduling)](#선점형-스케줄링-preemptive-scheduling)
    * [비선점형 스케줄링 (Non-Preemptive Scheduling)](#비선점형-스케줄링-non-preemptive-scheduling)
    * [무엇을 기준으로 운영 체제는 스케줄링 방식을 선택하는가](#무엇을-기준으로-운영-체제는-스케줄링-방식을-선택하는가)
    * [✏️ Appendix](#appendix)
    * [추가 정리](#추가-정리)
<!-- TOC -->

---


# ◼︎ 프로세스(Process)

프로세스는 **컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램**이다. 메모리에 올라와 실행되고 있는 프로그램의 인스턴스로, **시스템 자원과 CPU를 할당받아 실행된다**. 각 프로세스는 **독립된 메모리 영역을** 가지며, 실행 상태, 우선 순위, 프로그램 카운터 등의 정보를 포함하는 프로세스 제어 블록(PCB)에 의해 관리된다.

---

프로세스를 생성하는 동안 운영 체제는 여러 작업을 수행한다. 프로세스를 식별하기 위해 PID가 필요한데, 운영체제는 다중 프로그래밍을 지원하기에 모든 프로세스를 추적해야 한다. 이 때 필요한 것이 **PCB**이다.

## 프로세스 제어 블록(PCB)

프로세스 제어 블록(PCB)은 운영체제가 **프로세스를 관리하기 위해 사용하는 데이터 구조이다.**

프로세스의 상태, 프로그램 카운터, CPU 레지스터, 우선순위, 메모리 관련 정보 등 프로세스의 중요한 정보를 저장하고 있다. 프로세스가 생성될 때마다 PCB도 생성되고, 프로세스가 소멸되면 PCB도 소멸된다.

### PCB에 저장되어 있는 정보

- 프로세스 현재 상태, 프로세스의 우선순위, 프로세스에 할당된 자원에 대한 정보, CPU 레지스터 정보

![image](https://github.com/subeenjeonHere/subeenjeonHere.github.io/assets/145312273/4f253dd3-ef78-4918-b7b2-38e330cd903b)


> ***프로세스 ID(PID):** 각 프로세스의 고유 식별자입니다. 
**프로세스 상태:** 프로세스가 현재 실행 중인지, 준비 중인지, 보류 중인지, 중지되었는지 여부를 나타냅니다. 프로그램 카운터는 다음에 실행될 명령어의 주소를 저장합니다. 
**CPU 레지스터:** 컨텍스트 전환을 위한 현재 CPU 레지스터 값을 저장합니다. 
**메모리 관리 정보:** 메모리 할당 및 프로세스 사용량에 대한 정보입니다.*
>

---

## ► 프로세스 상태 전이

### 프로세스 상태 전이란

프로세스 상태 전이는 운영 체제가 프로세스 관리를 효율적으로 수행하기 위한 기능이다. 프로세스는 **생성, 준비, 실행, 대기, 종료** 등 다양한 상태를 가지며, 이러한 상태는 프로세스의 수행 과정에 따라 변한다. 이 상태의 변화를 관리하고 추적함으로써 운영 체제는 CPU 스케줄링을 효율적으로 수행하고, 시스템 자원을 적절히 할당하며, 프로세스 간의 동기화 문제를 해결할 수 있다.

프로세스는 생성되어 실행되고 종료될 때까지 아래와 같은 상태 전이를 거치게 된다.

| 상태 | 설명 |
| --- | --- |
| 시작(Start) | 프로세스가 처음 생성 |
| 준비(Ready) | 프로세스가 CPU를 할당받기를 기다리며, 이 상태에서 스케줄러에 의해 CPU가 할당 |
| 실행(Running) | CPU가 프로세스에 할당되어 명령어들이 실행되는 상태 |
| 대기(Waiting) | 프로세스가 어떤 이벤트(예: I/O 작업)를 기다리는 상태. 이 이벤트가 발생하면 프로세스는 다시 준비 상태가 된다. |
| 종료(Terminated) | 프로세스의 실행이 완료되었고, 프로세스가 시스템에서 제거되는 상태 |

![image](https://github.com/subeenjeonHere/subeenjeonHere.github.io/assets/145312273/91b7c915-623b-4745-8382-b172547e5599)

### 상태 전이 동작

| 동작 | 설명 |
| --- | --- |
| 준비→실행(Dispatch) | 우선순위가 높은 프로세스 선정하여 명령어 실행 |
| 실행→준비(Timer runout) | 클럭이 인터럽트를 발생시켜 제어권을 빼앗음(Preemption, 독점 방지) |
| 실행→대기(Block) | 프로세서가 입출력, 자원 등을 기다리기 위해 대기로 전환 |
| 대기→준비(Wake up) | 입출력이 완료되거나 자원이 할당되어 다시 실행 |
| Swap-out(Suspend) | 준비(대기) 상태에서 기억 장치를 반납하고 지연 준비(지연 대기) 상태로 전이 |
| Swap-in(Resume) | 지연 준비(지연 대기) 상태에서 기억 장치를 할당받아 준비(대기) 상태로 전이 |

### 상태 종류

| 상태 | 설명 |
| --- | --- |
| New | 프로세스가 막 생성된 상태 |
| Ready | 프로세스가 CPU에 실행되기 위해 대기하는 상태 |
| Running | 프로세스에 포함된 명령어가 실행되고 있는 상태 |
| Waiting | 프로세스가 특정 자원이나 이벤트를 기다리는 상태 |
| Suspended Waiting | 프로세스가 대기 상태에서 기억 장치를 잃은 상태 |
| Suspended Ready | 프로세스가 기억장치를 제외한 다른 모든 필요한 자원들을 보유한 상태 |
| Terminated | 프로세스가 실행을 완료한 상태 |

---

# ◼︎ 프로세스 교착상태

## 프로세스 교착상태(데드락, Deadlock)

![image](https://github.com/subeenjeonHere/subeenjeonHere.github.io/assets/145312273/1f42a947-271a-4147-b17b-12be7c99493b)


**두 개 이상의 프로세스가 서로 상대방에게 할당된 자원을 요구하면서 무한 대기 상태에** 빠지는 현상을 말한다.

### 교착상태는 왜 발생하는가?

교착상태가 발생하는 네 가지 조건

| No | 항목 | 설명 |
| --- | --- | --- |
| 1 | 상호 배제(Mutual Exclusion) | 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태 |
| 2 | 점유와 대기(Hold and Wait) | 자원을 할당받은 상태에서 다른 자원을 할당 받기를 기다리는 상태 |
| 3 | 비선점(Non-Preemption) | 어떤 프로세스도 다른 프로세스의 자원을 강제로 뺏지 못하는 상태 |
| 4 | 환형(순환) 대기(Circular Wait). | 이미 자원을 가진 프로세스가 앞, 뒤의 프로세스를 요구한다. 즉, 원의 형태로 자원을 대기하는 상태 |

### 교착상태를 예방할 방법은?

| No | 항목 | 설명 |
| --- |-----| --- |
| 1 | 예방 | 교착상태가 발생하지 않도록 사전에 시스템을 제어 |
| 2 | 회피 | 교착상태의 발생 가능성을 인정하고, 교착상태가 발생하려고 할 때 <br/>교착상태 가능성을 피해가는 방법 → 주로 은행가 알고리즘, Wound-Wait, Wait-Die를 사용 |
| 3 | 발견 | 교착상태 발생여부를 검사하여 교착상태에 빠진 프로세스와 자원을 발견 |
| 4 | 회복 | 교착상태에 빠진 프로세스를 종료하거나, 자원을 선점하여 다른 프로세스에 할당 |

---

# ◼︎ 스레드(Thread)

## 스레드

프로세스 내에서 **실제로 작업을 수행하는 주체**로, 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행한다. 또한, 환경에 따라 두 개 이상의 스레드를 가지는 프로세스를 **멀티스레드 프로세스**라고 한다.

---

## 프로세스와 스레드의 차이?

내가 이해한 바로는 스레드는 **프로세스의 하위 집합**이다. 실제 프로세스와 유사하지만, 프로세스의 컨텍스트 내에서 실행되고 커널이 프로세스에 할당한 동일한 리소스를 공유하기에 ‘경량 프로세스’ 라고도 할 수 있다.

|  | 프로세스 | 스레드 |
| --- | --- | --- |
| 1 | 모든 프로그램이 실행 중 | 프로세스의 일부 |
| 2 | 프로세스 생성, 종료에 더 많은 시간 소요 | 생성, 종료 시간이 프로세스보다 less 소요 |
| 3 | 컨텍스트 전환에 더 많은 시간 소요 | 컨텍스트 전환에 시간 less 소요 |
| 4 | - | 스레드는 주로 통신 측면에서 효율적 |
| 5 | - | 단일 프로세스가 여러 스레드로 구성되므로, 여러 프로그램을 실행할 필요가 없다 |

### 즉, 프로세스와 스레드의 차이는

- 프로세스는 독립적인 실행 환경을 가지며, 스레드는 프로세스의 하위 집합으로서 해당 프로세스의 리소스를 공유한다.
- 프로세스의 생성 및 종료에는 많은 시간이 소요되지만, 스레드의 생성 및 종료는 비교적 빠르다.
- 프로세스 간의 컨텍스트 전환은 시간이 많이 소요되지만, 스레드 간의 컨텍스트 전환은 빠른 편이다.
- 스레드는 통신 측면에서 효율적이며, 단일 프로세스 내에서 여러 작업을 동시에 처리할 수 있다.

### 왜 프로세스와 스레드를 분리한 거지

궁극적 이유는 효율적인 시스템 운영과 자원 관리.

프로세스는 **독립적인 실행 환경을 가지며 서로 다른 프로세스 간에는 자원을 공유하지 않는다**. 그러나 이러한 독립성은 프로세스 간 통신을 복잡하게 만들고, 프로세스를 생성하거나 제거하는 데 상대적으로 많은 비용이 들게 한다.

반면에, 스레드는 **같은 프로세스 내에서 메모리와 자원을 공유하면서 독립적으로 실행**될 수 있다. 이는 스레드 간 통신을 간단하게 만들고, 스레드를 생성하거나 제거하는 데 드는 비용을 줄인다. 또한, **하나의 프로세스 내에서 두 개 이상의 스레드가 동시에 작업하는 멀티 스레딩은 프로세스 내에서 병렬 작업**을 가능하게 하여 프로그램의 효율성을 높일 수 있다.

---

# ◼︎ 프로세스 스케쥴링

프로세스 스케쥴링에는 선점형, 비선점형 스케쥴링이 있다.

### 선점형 스케줄링 (Preemptive Scheduling)

선점형 스케줄링에서, 운영체제는 **현재 실행 중인 프로세스를 중지**하고 다른 프로세스를 실행할 수 있는 권한을 가지고 있다. 이는 새로운 프로세스가 **더 높은 우선순위**를 가지고 있거나, 현재 실행 중인 프로세스가 필요한 시간을 초과했을 때 발생한다.

> SRT, MLQ(다단계 큐), MLFQ(다단계 피드백 큐), RR(라운드-로빈)
>

### 비선점형 스케줄링 (Non-Preemptive Scheduling)

한편, 비선점형 스케줄링에서는 **한 프로세스가 시작되면 완료될 때까지 계속 실행된다**. 운영체제는 일단 프로세스가 CPU를 할당받으면 그 프로세스가 종료되거나 대기 상태로 전환될 때까지 CPU를 회수할 수 없다. 이 방식의 주요 이점은 프로세스가 자원을 독점하고, 결과를 보장하고, 일관성을 유지할 수 있다는 점이다. 하지만 이 방식은 프로세스의 실행 시간이 길 경우 다른 프로세스가 오랫동안 대기해야 하는 단점이 있다.

> 우선순위, 기한부, HRN, FCFS, SJF
>

---

### 무엇을 기준으로 운영 체제는 스케줄링 방식을 선택하는가

1. **시스템의 성능 목표**: 시스템이 **높은 처리량**을 목표로 하거나, 사용자의 **응답 시간을 최소화**하는 것이 중요한 경우 **선점형 스케줄링**을 사용한다. 반면, 시스템이 **안정적인 성능**을 유지하는 것이 중요한 경우 **비선점형 스케줄링**을 선택할 수 있다.
2. **프로세스의 특성**: 프로세스가 사용자와의 **상호작용을 많이 하는 경우**(예: GUI 애플리케이션) 빠른 응답 시간이 필요하여 **선점형 스케줄링**이 적합할 수 있다. 반면, **배치 처리**와 같이 사용자와의 상호작용이 적고 일관된 성능이 필요한 프로세스는 **비선점형 스케줄링이 적합**하다.
3. **시스템의 자원 상태**: 시스템의 CPU 사용률, 메모리 사용량 등 자원의 상태에 따라 스케줄링 방식을 선택할 수 있다. 예를 들어, CPU 사용률이 높은 경우 선점형 스케줄링을 통해 CPU 자원을 공정하게 분배할 수 있다.

---

2024년 2월 20일

### ✏️ Appendix

### 추가 정리

- **멀티프로세싱**: 컴퓨터 시스템은 한 번에 **여러 프로세스를 실행**할 수 있다. 이를 멀티프로세싱이라고 한다. 이를 위해 운영체제는 CPU 스케줄링 알고리즘을 사용하여 각 프로세스에 CPU를 공정하게 할당한다.
- **프로세스 제어 블록 (PCB)**: **PCB는 운영체제가 각 프로세스를 관리하기 위해 사용**하는 데이터 구조이다. PCB는 프로세스의 상태, 프로그램 카운터, CPU 레지스터, CPU 스케줄링 정보 등 프로세스에 관한 모든 정보를 포함한다.
- **문맥교환, 컨텍스트 스위칭 (Context Switching)**: 프로세스는 실행 중에 CPU를 다른 프로세스에게 넘겨야 할 때가 있다. 이러한 전환을 **컨텍스트 스위칭**이라고 한다. 컨텍스트 스위칭 발생 시, 현재 실행 중인 프로세스의 상태가 **PCB에 저장**되고, 다음에 실행될 프로세스의 상태가 PCB에서 CPU로 로드된다. 이 과정은 오버헤드를 발생시키지만, 여러 프로세스를 공정하게 실행하도록 한다.
- **프로세스 디스패치:** 준비 상태에 있는 프로세스 중에서 **CPU를 할당받아 실행 상태**로 바뀌는 과정을 말한다. 이 과정에서 스케줄러가 프로세스의 우선순위 등을 고려하여 CPU를 할당받을 프로세스를 결정하게 된다.
